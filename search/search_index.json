{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Quantum Trader Pro","text":"<p>Quantum Trader Pro is an institutional-grade crypto trading platform that combines AI-generated strategies with advanced real-time technical analysis. It's designed to provide a powerful, scalable, and insightful trading environment.</p> <p>This documentation provides a comprehensive guide to understanding, setting up, and extending the Quantum Trader Pro system.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u26a1 Real-Time Signal Processing: A WebSocket-based architecture for instant communication between the Python backend and React frontend.</li> <li>\ud83e\udde0 AI-Powered Strategy Generation: Leverage large language models to create and validate trading strategies from natural language prompts.</li> <li>\ud83d\udd2c Advanced Technical Indicators: Includes two proprietary indicators, the Quantum Cipher and the Quantum Volume Profile, for deep market analysis.</li> <li>\ud83c\udfd7\ufe0f Decoupled &amp; Scalable: Built on a microservices-friendly architecture using Docker, FastAPI, and Redis for high performance and scalability.</li> <li>\ud83d\udd27 Developer-First Environment: Pre-configured for rapid development and testing within GitHub Codespaces.</li> </ul>"},{"location":"#where-to-go-next","title":"Where to Go Next","text":"<p>Get Started in 5 Minutes View the System Architecture</p>"},{"location":"configuration/","title":"Configuration &amp; API Keys","text":"<p>Quantum Trader Pro requires API keys and other secrets to connect to exchanges and data providers. To handle these securely, the project uses a <code>.env</code> file.</p> <p>Never Commit Your Secrets</p> <p>The <code>.env</code> file should NEVER be committed to Git or shared publicly. It contains your private credentials. The project's <code>.gitignore</code> file is already configured to ignore this file, but you must always be vigilant.</p>"},{"location":"configuration/#how-to-set-up-your-configuration","title":"How to Set Up Your Configuration","text":"<ol> <li> <p>Create the File: In the root directory of the project, create a new file named <code>.env</code>.</p> </li> <li> <p>Add Your Keys: Open the <code>.env</code> file and add your keys in the <code>KEY=VALUE</code> format. Below is a sample structure you can use as a template.</p> <pre><code># --- Exchange APIs ---\n# Used for fetching market data and executing trades\nBINANCE_API_KEY=your_binance_api_key_here\nBINANCE_API_SECRET=your_binance_api_secret_here\n\n# --- Data Provider APIs ---\n# (Optional) For additional market data or analytics\nCOINMARKETCAP_API_KEY=your_coinmarketcap_api_key\n\n# --- Notification Systems ---\n# (Optional) For sending alerts\nTELEGRAM_BOT_TOKEN=your_bot_token\nTELEGRAM_CHAT_ID=your_chat_id\n\n# --- Internal Connections ---\n# This is pre-configured for Docker, no need to change for local dev\nREDIS_URL=redis://redis:6379\n</code></pre> </li> </ol>"},{"location":"configuration/#how-the-application-uses-these-keys","title":"How the Application Uses These Keys","text":"<p>The Python backend (FastAPI) and various scripts will automatically load these variables from your <code>.env</code> file when the application starts. You do not need to hardcode them anywhere in the application logic.</p>"},{"location":"getting-started/","title":"Getting Started in 5 Minutes","text":"<p>This guide will take you from zero to a fully running Quantum Trader Pro environment, right in your browser.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>A GitHub Account.</li> <li>GitHub Codespaces enabled for your account.</li> </ul>"},{"location":"getting-started/#step-1-open-the-project-in-codespaces","title":"Step 1: Open the Project in Codespaces","text":"<p>This is the easiest step. On the main page of the GitHub repository, click the green <code>&lt; &gt; Code</code> button, navigate to the Codespaces tab, and click \"Create codespace on main\".</p> <p>This will launch a complete, containerized development environment in your browser.</p>"},{"location":"getting-started/#step-2-start-all-services","title":"Step 2: Start All Services","text":"<p>Once your Codespace terminal is ready, run the following single command. This will build the Docker containers for the backend, frontend, and Redis, and then start them all up.</p> <pre><code>docker-compose up --build\n</code></pre> <p>You will see a lot of log output as the services start. This is normal.</p> <p>Step 3: Verify Everything is Running</p> <p>The system is now live! GitHub Codespaces automatically forwards the necessary ports.</p> <p>Check the Backend: Open http://localhost:8000 in a new browser tab. You should see {\"status\":\"OK\",\"message\":\"Quantum Trader Pro Backend is Live!\"}.</p> <p>Check the Frontend: Open http://localhost:3000. You'll see the basic \"Quantum Trader Pro UI\".</p> <p>Confirm the Real-Time Connection: With the frontend tab open, check the browser's developer console (usually F12 or Ctrl+Shift+I). You should see the message: \u2705 Connected to WebSocket.</p> <p>\ud83c\udf89 That's it! You now have a live, real-time connection between the frontend and backend.</p> <p>What's Next?</p> <p>Curious how all the pieces fit together? For a detailed explanation of the container setup, WebSocket connections, and real-time architecture, dive into the full tutorial.</p> <p>View the Full Real-Time Setup Tutorial{ .md-button }</p>"},{"location":"concepts/ai-learning-system/","title":"The AI Learning System","text":"<p>To enable the AI trading system to learn, adapt, and improve its performance over time, we use a continuous feedback loop. This document outlines the key components and processes involved.</p>"},{"location":"concepts/ai-learning-system/#core-components-for-learning","title":"Core Components for Learning","text":"<p>For the AI to analyze and improve, it needs access to several key data sources:</p> Data Source Purpose Exchange APIs (Binance, Bybit) Real-time price data, order execution history. On-Chain Data (Etherscan) Wallet tracking, smart contract events. Market Intelligence (Glassnode) Market sentiment, liquidity data, on-chain analytics. News/Sentiment APIs (CryptoPanic) Event detection and news-driven sentiment analysis."},{"location":"concepts/ai-learning-system/#the-feedback-loop","title":"The Feedback Loop","text":"<p>The core of the learning process is a cycle where the results of past trades are used to improve future decisions.</p> <pre><code>graph LR\n    A[Trade Execution] --&gt; B{Performance Metrics};\n    B --&gt; C[Win/Loss &amp; Slippage Analysis];\n    C --&gt; D[AI Strategy Adjuster];\n    D --&gt; E[Model Retraining &amp; Validation];\n    E --&gt; A;\n</code></pre> <p>This loop consists of: Trade Execution: A trade is made based on the current AI model. Performance Metrics: The outcome of the trade (profit, loss, slippage, fees) is recorded. Analysis: The system analyzes why the trade succeeded or failed, considering the market conditions at the time. Strategy Adjustment: The AI model proposes adjustments to its internal parameters or rules. Retraining: The model is retrained with the new data and validated against historical data before being deployed. Reinforcement Learning Parameters To guide its learning, the AI uses a set of high-level goals and risk parameters. These act as its \"personality\" and strategic objectives.</p> <pre><code>{\n  \"risk_parameters\": {\n    \"max_drawdown_percent\": 15,\n    \"daily_loss_limit_percent\": 5\n  },\n  \"learning_goals\": {\n    \"target_sharpe_ratio\": 2.5,\n    \"win_rate_improvement_goal\": \"5% quarterly\"\n  },\n  \"personality_profile\": {\n    \"trading_style\": \"swing_trader\",\n    \"fomo_resistance\": \"medium\"\n  }\n}\n</code></pre> <p>By providing these elements, the AI can learn your historical decision patterns, adapt to your risk tolerance, and continuously refine its strategies to discover new market opportunities. code.</p>"},{"location":"concepts/system-architecture/","title":"System Architecture","text":"<p>This document provides a high-level overview of the Quantum Trader Pro architecture, its core components, and the technology stack.</p>"},{"location":"concepts/system-architecture/#core-philosophy-a-hybrid-approach","title":"Core Philosophy: A Hybrid Approach","text":"<p>The system is built on a hybrid model that balances speed of development with granular control over critical components:</p> <ul> <li>AI Builders for UI &amp; Admin: A platform like Dify.ai or Bubble can be used to rapidly develop the user interface, dashboards, and administrative panels. This handles 80% of the standard web application features.</li> <li>Custom Python Backend for Trading Logic: The core trading engine, signal processing, and AI strategy generation are written in custom Python to ensure maximum performance, control, and flexibility.</li> </ul> <p>This approach allows for a fast, iterative development cycle for the user-facing parts of the app while reserving deep, custom engineering for the mission-critical trading core.</p>"},{"location":"concepts/system-architecture/#high-level-flow","title":"High-Level Flow","text":"<p>The data and command flow through the system is designed to be decoupled and scalable.</p> <pre><code>graph LR\n    A[UI / AI Builder] --&gt; B[API Gateway / FastAPI];\n    B --&gt; C{Trading Logic Router};\n    C --&gt; D[Quantum Cipher Engine];\n    C --&gt; E[Quantum Volume Profile];\n    C --&gt; F[AI Strategy Generator];\n    D &amp; E &amp; F --&gt; G[Signal Confirmation];\n    G --&gt; H[Execution Service];\n    H --&gt; I[Exchange APIs];\n</code></pre> <p>Technology Stack The system leverages a modern, robust set of tools and services, categorized by their function. \ud83e\udde0 AI &amp; Prompt Engineering Gemini Build (Google AI): AI copilot for building the application. LLM APIs (Gemini, Mixtral): Used for conversational assistance and strategy generation. LangChain: The framework for building and orchestrating AI agents. \ud83d\udcbb Backend &amp; Development FastAPI: High-performance Python framework for the API backend. Redis: In-memory data store for caching and real-time Pub/Sub messaging. Socket.IO: Enables real-time, bidirectional communication with the frontend. Docker / Docker Compose: Containerizes all services for a reproducible and scalable environment. GitHub Codespaces: Cloud-based development environment. \u269b\ufe0f Frontend React: The primary UI framework for building interactive components. Vite or Next.js: Modern frontend tooling for building and serving the UI. \ud83d\udcca Data &amp; Infrastructure TimescaleDB: A time-series database (PostgreSQL extension) for storing market data. Kafka (Optional): Can be added later as a scalable message bus for high-throughput data pipelines.</p>"},{"location":"reference/quantum-cipher/","title":"API Reference: Quantum Cipher","text":"<p>This document provides a technical reference for the <code>Quantum Cipher</code> signal generation module. This module is responsible for calculating momentum, volume, and trend-based signals.</p>"},{"location":"reference/quantum-cipher/#core-logic","title":"Core Logic","text":"<p>The Quantum Cipher combines several standard indicators into a single, cohesive signal: 1.  An Adaptive Momentum Oscillator to gauge the speed and direction of price changes. 2.  A Volume-Weighted Confirmation using VWAP and a volume spike ratio to ensure conviction. 3.  A Dual EMA Trend Filter to ensure signals are only taken in the direction of the prevailing trend.</p>"},{"location":"reference/quantum-cipher/#functions","title":"Functions","text":""},{"location":"reference/quantum-cipher/#calculate_quantum_cipherdf","title":"<code>calculate_quantum_cipher(df)</code>","text":"<p>Calculates the full set of Quantum Cipher signals from a market data DataFrame.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>df</code> (pandas.DataFrame): A DataFrame containing OHLCV data with the following columns: <code>timestamp</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>, <code>volume</code>.</li> </ul> </li> <li> <p>Returns: (pandas.DataFrame)</p> <ul> <li>A new DataFrame with the original OHLCV data plus several calculated columns, including:<ul> <li><code>vwap</code>: The Volume-Weighted Average Price.</li> <li><code>osc</code>: The final Momentum Oscillator value.</li> <li><code>buy_signal</code> (bool): <code>True</code> if a buy signal is generated for a given candle.</li> <li><code>sell_signal</code> (bool): <code>True</code> if a sell signal is generated for a given candle.</li> </ul> </li> </ul> </li> <li> <p>Usage Example: <pre><code>import pandas as pd\nfrom app.logic.cipher import fetch_market_data, calculate_quantum_cipher\n\n# 1. Fetch market data\nmarket_df = fetch_market_data('binance', 'BTC/USDT', '1h')\n\n# 2. Calculate signals\nif not market_df.empty:\n    signals_df = calculate_quantum_cipher(market_df)\n    print(signals_df[['timestamp', 'close', 'buy_signal', 'sell_signal']].tail())\n</code></pre></p> </li> </ul>"},{"location":"reference/quantum-cipher/#fetch_market_dataexchange-symbol-timeframe-limit1000","title":"<code>fetch_market_data(exchange, symbol, timeframe, limit=1000)</code>","text":"<p>Fetches historical OHLCV data from a specified cryptocurrency exchange using the <code>ccxt</code> library.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>exchange</code> (str): The ID of the exchange (e.g., <code>'binance'</code>).</li> <li><code>symbol</code> (str): The trading pair symbol (e.g., <code>'BTC/USDT'</code>).</li> <li><code>timeframe</code> (str): The candle timeframe (e.g., <code>'15m'</code>, <code>'1h'</code>, <code>'1d'</code>).</li> <li><code>limit</code> (int, optional): The number of candles to fetch. Defaults to <code>1000</code>.</li> </ul> </li> <li> <p>Returns: (pandas.DataFrame)</p> <ul> <li>A DataFrame containing the requested OHLCV data.</li> </ul> </li> </ul>"},{"location":"reference/quantum-cipher/#full-source-code","title":"Full Source Code","text":"Click to view the full source code for `cipher.py` <pre><code>import pandas as pd\nimport numpy as np\nimport ccxt\nimport time\n\ndef calculate_quantum_cipher(df):\n    \"\"\"\n    Calculate Quantum Cipher signals from market data\n    \"\"\"\n    # 1. Calculate core price values\n    df['hlc3'] = (df['high'] + df['low'] + df['close']) / 3\n\n    # 2. Adaptive Momentum Oscillator\n    df['mom'] = df['hlc3'].diff()\n    df['abs_mom'] = df['mom'].abs()\n    df['smooth_mom'] = df['mom'].ewm(span=14, adjust=False).mean()\n    df['smooth_abs'] = df['abs_mom'].ewm(span=14, adjust=False).mean()\n    df['osc'] = 100 * df['smooth_mom'] / (df['smooth_abs'] + 1e-9) # Avoid division by zero\n\n    # 3. Volume-Weighted Confirmation\n    cumulative_vp = (df['hlc3'] * df['volume']).cumsum()\n    cumulative_vol = df['volume'].cumsum()\n    df['vwap'] = cumulative_vp / (cumulative_vol + 1e-9) # Avoid division by zero\n    df['volume_sma20'] = df['volume'].rolling(window=20).mean()\n    df['v_ratio'] = df['volume'] / (df['volume_sma20'] + 1e-9) # Avoid division by zero\n\n    # 4. Trend Filter\n    df['ema_fast'] = df['close'].ewm(span=8, adjust=False).mean()\n    df['ema_slow'] = df['close'].ewm(span=21, adjust=False).mean()\n\n    # 5. Signal Conditions\n    df['bull_vol'] = (df['close'] &gt; df['vwap']\n&lt;/details&gt;\n</code></pre>"},{"location":"reference/quantum-volume-profile/","title":"API Reference: Quantum Volume Profile","text":"<p>This document provides a technical reference for the <code>QuantumVolumeProfile</code> class. This class is an enhanced volume profile analyzer that provides deep insights into market structure, value areas, and key support/resistance levels.</p>"},{"location":"reference/quantum-volume-profile/#core-logic","title":"Core Logic","text":"<p>The <code>QuantumVolumeProfile</code> class is a stateful analyzer that processes market data bar-by-bar to build a volume profile over a dynamic range. Its key features include:</p> <ul> <li>Dynamic Range Selection: Can build profiles for a single session, a rolling window, or a fixed anchor date.</li> <li>Key Level Calculation: Automatically identifies the Point of Control (POC), Value Area (VAL/VAH), High Volume Nodes (HVN), and Low Volume Nodes (LVN).</li> <li>Signal Generation: Provides actionable trading signals based on the price's relationship to the calculated volume profile levels.</li> </ul>"},{"location":"reference/quantum-volume-profile/#class-quantumvolumeprofile","title":"Class: <code>QuantumVolumeProfile</code>","text":""},{"location":"reference/quantum-volume-profile/#__init__self-range_typesession-window20-anchor_datenone","title":"<code>__init__(self, range_type='session', window=20, anchor_date=None)</code>","text":"<p>Initializes the volume profile analyzer.</p> <ul> <li>Parameters:<ul> <li><code>range_type</code> (str): The type of profile to build. Can be <code>'session'</code>, <code>'rolling'</code>, <code>'anchor'</code>, or <code>'visible'</code>.</li> <li><code>window</code> (int): The number of bars for a <code>'rolling'</code> profile.</li> <li><code>anchor_date</code> (datetime, optional): The start date for an <code>'anchor'</code> profile.</li> </ul> </li> </ul>"},{"location":"reference/quantum-volume-profile/#update_profileself-bar_data","title":"<code>update_profile(self, bar_data)</code>","text":"<p>Updates the profile with a new bar of market data.</p> <ul> <li>Parameters:<ul> <li><code>bar_data</code> (dict or pandas.Series): A dictionary or Series containing OHLCV data for a single bar, including <code>timestamp</code>, <code>high</code>, <code>low</code>, and <code>volume</code>.</li> </ul> </li> </ul>"},{"location":"reference/quantum-volume-profile/#get_profile_summaryself","title":"<code>get_profile_summary(self)</code>","text":"<p>Returns a dictionary containing a comprehensive summary of the current profile state.</p> <ul> <li>Returns: (dict)<ul> <li>A dictionary with keys like <code>poc_price</code>, <code>val</code>, <code>vah</code>, <code>hvn_count</code>, <code>lvn_count</code>, etc.</li> </ul> </li> </ul>"},{"location":"reference/quantum-volume-profile/#get_signalsself-current_price-current_volume","title":"<code>get_signals(self, current_price, current_volume)</code>","text":"<p>Generates a list of trading signals based on the current price's position relative to the volume profile.</p> <ul> <li>Parameters:<ul> <li><code>current_price</code> (float): The current market price.</li> <li><code>current_volume</code> (float): The volume of the current bar.</li> </ul> </li> <li> <p>Returns: (list)</p> <ul> <li>A list of strings representing active signals (e.g., <code>['VAH_BREAKOUT', 'REVERSION_TO_POC']</code>).</li> </ul> </li> <li> <p>Usage Example: <pre><code>from app.logic.volume_profile import QuantumVolumeProfile\nimport pandas as pd\n\n# Initialize for a daily session profile\nqvp = QuantumVolumeProfile(range_type='session')\n\n# Assume 'market_data_df' is a DataFrame with historical data\nfor index, bar in market_data_df.iterrows():\n    # Update the profile with each new bar\n    qvp.update_profile(bar)\n\n    # Check for signals\n    signals = qvp.get_signals(bar['close'], bar['volume'])\n    if signals:\n        print(f\"Time: {bar['timestamp']}, Signals: {signals}\")\n\n# Get a summary at the end of the session\nsummary = qvp.get_profile_summary()\nprint(\"Session Summary:\", summary)\n</code></pre></p> </li> </ul>"},{"location":"reference/quantum-volume-profile/#full-source-code","title":"Full Source Code","text":"Click to view the full source code for `volume_profile.py` <pre><code>import pandas as pd\nimport numpy as np\nfrom collections import defaultdict\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\nclass QuantumVolumeProfile:\n    def __init__(self, range_type='session', window=20, anchor_date=None):\n        self.range_type = range_type\n        self.window = window\n        self.anchor_date = anchor_date\n        self.profile = defaultdict(float)\n        self.total_volume = 0.0\n        self.poc_price = None\n        self.poc_volume = 0.0\n        self.val = None\n        self.vah = None\n        self.hvn = []\n        self.lvn = []\n        self.last_bar_time = None\n\n    def reset_profile(self):\n        self.profile = defaultdict(float)\n        self.total_volume = 0.0\n        # ... reset other attributes\n\n    def _should_reset(self, bar_time):\n        if self.range_type == 'session':\n            if self.last_bar_time is None:\n                return True\n            return bar_time.date() != self.last_bar_time.date()\n        return False\n\n    def update_profile(self, bar_data):\n        timestamp = pd.to_datetime(bar_data['timestamp'])\n        high = float(bar_data['high'])\n        low = float(bar_data['low'])\n        volume = float(bar_data['volume'])\n\n        if self._should_reset(timestamp):\n            self.reset_profile()\n\n        price_range = np.linspace(low, high, num=int((high - low) / 0.5) + 1) # Example resolution\n        vol_per_price = volume / len(price_range) if price_range.size &gt; 0 else 0\n\n        for price in price_range:\n            price_level = round(price * 2) / 2 # Round to nearest 0.5\n            self.profile[price_level] += vol_per_price\n            self.total_volume += vol_per_price\n\n        self.last_bar_time = timestamp\n        self._calculate_metrics()\n\n    def _calculate_metrics(self):\n        if not self.profile:\n            return\n\n        prices = np.array(sorted(self.profile.keys()))\n        volumes = np.array([self.profile[p] for p in prices])\n\n        # 1. Find POC\n        poc_idx = np.argmax(volumes)\n        self.poc_price = prices[poc_idx]\n        self.poc_volume = volumes[poc_idx]\n\n        # 2. Calculate Value Area (70%)\n        sorted_indices = np.argsort(volumes)[::-1]\n        cumulative_vol = 0\n        value_area_indices = []\n        for idx in sorted_indices:\n            cumulative_vol += volumes[idx]\n            value_area_indices.append(idx)\n            if cumulative_vol &gt;= self.total_volume * 0.7:\n                break\n        value_area_prices = prices[value_area_indices]\n        self.val = np.min(value_area_prices)\n        self.vah = np.max(value_area_prices)\n\n        # 3. Identify HVN/LVN (statistical approach)\n        mean_vol = np.mean(volumes)\n        std_vol = np.std(volumes)\n        self.hvn = prices[volumes &gt; mean_vol + 1.5 * std_vol].tolist()\n        self.lvn = prices[volumes &lt; mean_vol - 0.5 * std_vol].tolist()\n\n    def get_profile_summary(self):\n        return {\n            'poc_price': self.poc_price,\n            'val': self.val,\n            'vah': self.vah,\n            # ... other summary data\n        }\n\n    def get_signals(self, current_price, current_volume):\n        signals = []\n        # Signal logic based on price relative to POC, VAL, VAH, HVNs, LVNs\n        # (Example)\n        if current_price &gt; self.vah and current_volume &gt; self.poc_volume * 0.5:\n             signals.append(\"VAH_BREAKOUT_CONFIRMED\")\n        return signals\n&lt;/details&gt;\n</code></pre>"},{"location":"tutorials/real-time-setup/","title":"Full Setup: Real-Time Architecture in Codespaces","text":"<p>This document outlines the exact steps to set up the full development environment in GitHub Codespaces to support the entire real-time application stack.</p>"},{"location":"tutorials/real-time-setup/#overview","title":"Overview","text":"<p>This tutorial covers:</p> <ul> <li>\u26a1 Real-time AI signal generation</li> <li>\ud83c\udf10 FastAPI + Socket.IO WebSocket backend</li> <li>\ud83d\udd01 React frontend with a WebSocket client</li> <li>\ud83d\udd27 A complete, containerized dev environment for scalability</li> </ul>"},{"location":"tutorials/real-time-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have completed the 5-Minute Quickstart.</li> <li>You have a basic understanding of Docker and <code>docker-compose</code>.</li> </ul>"},{"location":"tutorials/real-time-setup/#1-project-structure-required-layout","title":"1. Project Structure (Required Layout)","text":"<p>For the system to work correctly, your repository must follow this structure:</p> <p>quantum-trader/ \u251c\u2500\u2500 .devcontainer/ \u2502 \u2514\u2500\u2500 devcontainer.json \u251c\u2500\u2500 docker-compose.yml \u251c\u2500\u2500 backend/ \u2502 \u251c\u2500\u2500 main.py \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u2514\u2500\u2500 app/ \u2502 \u2514\u2500\u2500 logic/ \u2502 \u2514\u2500\u2500 cipher.py \u2514\u2500\u2500 frontend/ \u251c\u2500\u2500 index.html \u251c\u2500\u2500 main.jsx \u2514\u2500\u2500 package.json</p> <p>code Code download content_copy expand_less IGNORE_WHEN_COPYING_START IGNORE_WHEN_COPYING_END</p>"},{"location":"tutorials/real-time-setup/#2-configure-codespaces-devcontainerdevcontainerjson","title":"2. Configure Codespaces: <code>.devcontainer/devcontainer.json</code>","text":"<p>This file defines the development container, telling Codespaces how to build the environment.</p> <pre><code>{\n  \"name\": \"quantum-trader-dev\",\n  \"dockerComposeFile\": \"docker-compose.yml\",\n  \"service\": \"backend\",\n  \"workspaceFolder\": \"/workspace/backend\",\n  \"settings\": {\n    \"terminal.integrated.shell.linux\": \"/bin/bash\"\n  },\n  \"extensions\": [\n    \"ms-python.python\",\n    \"ms-azuretools.vscode-docker\",\n    \"esbenp.prettier-vscode\"\n  ],\n  \"postCreateCommand\": \"pip install -r requirements.txt\"\n}\n</code></pre> <ol> <li>Container Composition: docker-compose.yml</li> </ol> <p>This file orchestrates all the services required for the application: the Python backend, the React frontend, and the Redis cache.</p> <pre><code>version: \"3.9\"\n\nservices:\n  backend:\n    build:\n      context: ./backend\n    container_name: fastapi_app\n    ports:\n      - \"8000:8000\"\n    volumes:\n      - ./backend:/workspace/backend\n    depends_on:\n      - redis\n    environment:\n      - REDIS_URL=redis://redis:6379\n    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload\n\n  redis:\n    image: redis:7-alpine\n    container_name: redis_cache\n    ports:\n      - \"6379:6379\"\n\n  frontend:\n    build:\n      context: ./frontend\n    container_name: react_ui\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - ./frontend:/app\n    command: npm run dev\n  ```\n\n4. FastAPI App Setup (with WebSocket)\n\nThe core of the backend is the main.py file, which sets up the FastAPI application and the Socket.IO manager for real-time communication.\n\n```json\n# located in backend/main.py\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi_socketio import SocketManager\nimport pandas as pd\n\nfrom app.logic.cipher import fetch_market_data, calculate_quantum_cipher\n\napp = FastAPI(title=\"Quantum Trader Pro API\")\nsio = SocketManager(app=app)\n\n# CORS for dev\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.get(\"/\")\ndef health_check():\n    return {\"status\": \"OK\", \"message\": \"Quantum Trader Pro Backend is Live!\"}\n\n@sio.on('connect')\nasync def connect(sid, environ):\n    print(f\"[WebSocket] Client connected: {sid}\")\n    await sio.emit('message', {'message': 'Connected to Quantum Trader WS'}, to=sid)\n\n@app.get(\"/ws-test\")\nasync def test_socket():\n    await sio.emit(\"new_signal\", {\"type\": \"test\", \"data\": \"\ud83d\udea8 Test signal from backend!\"})\n    return {\"status\": \"Signal emitted\"}\n</code></pre> <p>This setup provides a health check endpoint, a WebSocket connection handler, and a test route to verify that real-time messages can be sent.</p>"}]}