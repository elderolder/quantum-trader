{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Quantum Trader Pro","text":"<p>Quantum Trader Pro is an institutional-grade crypto trading platform that combines AI-generated strategies with advanced real-time technical analysis. It's designed to provide a powerful, scalable, and insightful trading environment.</p> <p>This documentation provides a comprehensive guide to understanding, setting up, and extending the Quantum Trader Pro system.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u26a1 Real-Time Signal Processing: A WebSocket-based architecture for instant communication between the Python backend and React frontend.</li> <li>\ud83e\udde0 AI-Powered Strategy Generation: Leverage large language models to create and validate trading strategies from natural language prompts.</li> <li>\ud83d\udd2c Advanced Technical Indicators: Includes two proprietary indicators, the Quantum Cipher and the Quantum Volume Profile, for deep market analysis.</li> <li>\ud83c\udfd7\ufe0f Decoupled &amp; Scalable: Built on a microservices-friendly architecture using Docker, FastAPI, and Redis for high performance and scalability.</li> <li>\ud83d\udd27 Developer-First Environment: Pre-configured for rapid development and testing within GitHub Codespaces.</li> </ul>"},{"location":"#where-to-go-next","title":"Where to Go Next","text":"<p>Get Started in 5 Minutes View the System Architecture</p>"},{"location":"ai-logic/indicator_definitions/","title":"Indicator Definitions","text":"<p>This document contains the pure Python source code for the proprietary trading indicators used in Quantum Trader Pro. This serves as the ground truth for the core signal generation logic.</p> <p>Audience: Gemini (Implementation) Goal: To provide a single, clean source for the Python code that should be placed in the <code>backend/app/logic/</code> directory.</p>"},{"location":"ai-logic/indicator_definitions/#1-quantum-cipher-quantum_cipherpy","title":"1. Quantum Cipher (<code>quantum_cipher.py</code>)","text":"<p>This indicator combines momentum, volume, and trend analysis to generate buy/sell signals.</p> <pre><code>import pandas as pd\nimport numpy as np\nimport ccxt\n\ndef calculate_quantum_cipher(df):\n    \"\"\"\n    Calculate Quantum Cipher signals from market data DataFrame.\n    \"\"\"\n    # 1. Calculate core price values\n    df['hlc3'] = (df['high'] + df['low'] + df['close']) / 3\n\n    # 2. Adaptive Momentum Oscillator\n    df['mom'] = df['hlc3'].diff()\n    df['abs_mom'] = df['mom'].abs()\n    df['smooth_mom'] = df['mom'].ewm(span=14, adjust=False).mean()\n    df['smooth_abs'] = df['abs_mom'].ewm(span=14, adjust=False).mean()\n    df['osc'] = 100 * df['smooth_mom'] / (df['smooth_abs'] + 1e-9)\n\n    # 3. Volume-Weighted Confirmation\n    cumulative_vp = (df['hlc3'] * df['volume']).cumsum()\n    cumulative_vol = df['volume'].cumsum()\n    df['vwap'] = cumulative_vp / (cumulative_vol + 1e-9)\n    df['volume_sma20'] = df['volume'].rolling(window=20).mean()\n    df['v_ratio'] = df['volume'] / (df['volume_sma20'] + 1e-9)\n\n    # 4. Trend Filter\n    df['ema_fast'] = df['close'].ewm(span=8, adjust=False).mean()\n    df['ema_slow'] = df['close'].ewm(span=21, adjust=False).mean()\n\n    # 5. Signal Conditions\n    df['bull_vol'] = (df['close'] &gt; df['vwap']) &amp; (df['v_ratio'] &gt; 1.2)\n    df['bear_vol'] = (df['close'] &lt; df['vwap']) &amp; (df['v_ratio'] &gt; 1.2)\n    df['uptrend'] = df['ema_fast'] &gt; df['ema_slow']\n    df['downtrend'] = df['ema_fast'] &lt; df['ema_slow']\n\n    # 6. Generate Signals\n    df['buy_signal'] = (df['osc'] &lt; -30) &amp; (df['osc'] &gt; df['osc'].shift(1)) &amp; df['bull_vol'] &amp; df['uptrend']\n    df['sell_signal'] = (df['osc'] &gt; 70) &amp; (df['osc'] &lt; df['osc'].shift(1)) &amp; df['bear_vol'] &amp; df['downtrend']\n\n    return df\n\ndef fetch_market_data(exchange, symbol, timeframe, limit=1000):\n    \"\"\"\n    Fetch historical market data using ccxt.\n    \"\"\"\n    try:\n        exchange_class = getattr(ccxt, exchange)()\n        ohlcv = exchange_class.fetch_ohlcv(symbol, timeframe, limit=limit)\n        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\n        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\n        return df\n    except Exception as e:\n        print(f\"Error fetching market data: {e}\")\n        return pd.DataFrame()\n</code></pre> <ol> <li>Quantum Volume Profile (quantum_volume.py)</li> </ol> <p>This class provides an enhanced volume profile analysis, identifying key levels like POC, VAL, and VAH.</p> <pre><code>import pandas as pd\nimport numpy as np\nfrom collections import defaultdict\n\nclass QuantumVolumeProfile:\n    \"\"\"\n    Enhanced Volume Profile analyzer with dynamic range selection and statistical node classification.\n    \"\"\"\n    def __init__(self, range_type='session', window=20, anchor_date=None):\n        self.range_type = range_type\n        self.window = window\n        self.anchor_date = anchor_date\n        self.profile = defaultdict(float)\n        self.total_volume = 0.0\n        self.poc_price = None\n        self.val = None\n        self.vah = None\n        self.last_bar_time = None\n\n    def reset_profile(self):\n        self.profile = defaultdict(float)\n        self.total_volume = 0.0\n        self.poc_price = None\n        self.val = None\n        self.vah = None\n\n    def _should_reset(self, bar_time):\n        if self.range_type == 'session':\n            if self.last_bar_time is None: return True\n            return bar_time.date() != self.last_bar_time.date()\n        return False\n\n    def update_profile(self, bar_data):\n        timestamp = pd.to_datetime(bar_data['timestamp'])\n        high = float(bar_data['high'])\n        low = float(bar_data['low'])\n        volume = float(bar_data['volume'])\n\n        if self._should_reset(timestamp):\n            self.reset_profile()\n\n        # Approximate volume distribution across the bar's price range\n        price_range = np.arange(low, high, 0.5) # Example: using a 0.5 price tick size\n        if len(price_range) &gt; 0:\n            vol_per_tick = volume / len(price_range)\n            for price in price_range:\n                self.profile[price] += vol_per_tick\n                self.total_volume += vol_per_tick\n\n        self.last_bar_time = timestamp\n        self._calculate_metrics()\n\n    def _calculate_metrics(self):\n        if not self.profile: return\n\n        prices = np.array(sorted(self.profile.keys()))\n        volumes = np.array([self.profile[p] for p in prices])\n\n        # Point of Control (POC)\n        poc_idx = np.argmax(volumes)\n        self.poc_price = prices[poc_idx]\n\n        # Value Area (VA) - 70% of volume\n        target_volume = self.total_volume * 0.7\n        cumulative_volume = 0\n        value_area_prices = []\n\n        # Start from POC and expand outwards\n        sorted_by_vol_desc = sorted(self.profile.items(), key=lambda item: item[1], reverse=True)\n\n        for price, vol in sorted_by_vol_desc:\n            value_area_prices.append(price)\n            cumulative_volume += vol\n            if cumulative_volume &gt;= target_volume:\n                break\n\n        if value_area_prices:\n            self.val = min(value_area_prices)\n            self.vah = max(value_area_prices)\n</code></pre>"},{"location":"ai-logic/prompt_templates/","title":"Prompt Templates","text":"<p>This document specifies the exact structure and content of the prompts that the Quantum Trader Pro application will send to external Large Language Models (LLMs) for tasks like strategy generation and market analysis.</p> <p>Audience: Gemini (Implementation), You (Strategy &amp; Design) Goal: To create a standard, reusable set of prompts that ensures consistent and high-quality responses from the LLMs.</p>"},{"location":"ai-logic/prompt_templates/#1-strategy-generation-prompt","title":"1. Strategy Generation Prompt","text":"<p>This template is used to ask an LLM to generate a trading strategy in a specific format (e.g., PineScript for TradingView).</p> <ul> <li>Target Model: Mixtral 8x7B (via Groq or another provider)</li> <li>Purpose: To convert a natural language request into a functional, testable trading algorithm.</li> </ul>"},{"location":"ai-logic/prompt_templates/#template-structure","title":"Template Structure","text":"<p>The prompt will be constructed in the Python backend using an f-string or a template engine. It will combine a fixed system message with dynamic user input.</p> <pre><code>def create_strategy_generation_prompt(market_conditions, user_request):\n    \"\"\"\n    Creates the full prompt for the LLM to generate a trading strategy.\n    \"\"\"\n\n    SYSTEM_MESSAGE = \"\"\"\nYou are an expert quantitative trading strategist specializing in cryptocurrency markets.\nYour task is to generate a complete, valid PineScript v5 trading strategy based on the user's request and the provided market conditions.\n\nThe generated script MUST include:\n1. A `strategy()` declaration with a unique name.\n2. Clear input controls for key parameters (e.g., moving average lengths, RSI levels).\n3. Explicit entry conditions for long (`strategy.entry`) and short (`strategy.exit`) positions.\n4. A basic stop-loss and take-profit mechanism.\n5. Plotting of key indicators on the chart.\n\nDo NOT include any explanatory text before or after the code block. Only output the pure PineScript code.\n\"\"\"\n\n    prompt = f\"\"\"\n{SYSTEM_MESSAGE}\n\n---\n**Current Market Conditions:**\n{market_conditions}\n\n**User Strategy Request:**\n\"{user_request}\"\n---\n\nGenerate the PineScript v5 code now.\n\"\"\"\n    return prompt\n</code></pre> <p>Example Usage</p> <p>market_conditions: \"BTC/USDT is in a sideways, range-bound market between $60,000 and $65,000. Volatility is low.\"</p> <p>user_request: \"Create a mean-reversion strategy using Bollinger Bands and RSI.\"</p> <p>The backend would generate the full prompt using the function above and send it to the Mixtral API.</p> <ol> <li>Market Sentiment Analysis Prompt</li> </ol> <p>This template is used to ask an LLM to analyze a piece of news or text and provide a structured sentiment score.</p> <p>Target Model: Gemini Pro</p> <p>Purpose: To extract structured sentiment data from unstructured text.</p> <pre><code>def create_sentiment_analysis_prompt(article_text):\n    \"\"\"\n    Creates the full prompt for the LLM to analyze sentiment.\n    \"\"\"\n\n    prompt = f\"\"\"\nAnalyze the following financial news article. Provide your analysis ONLY in the form of a valid JSON object.\n\nThe JSON object must have these exact keys:\n- \"sentiment\": A string, either \"Bullish\", \"Bearish\", or \"Neutral\".\n- \"confidence_score\": A float between 0.0 and 1.0.\n- \"summary\": A one-sentence summary of the key takeaway from the article.\n- \"key_topics\": A JSON array of strings listing the main topics (e.g., [\"inflation\", \"interest rates\", \"BTC ETF\"]).\n\nDo not include any text before or after the JSON object.\n\n---\n**Article Text:**\n\"{article_text}\"\n---\n\nGenerate the JSON response now.\n\"\"\"\n    return prompt\n</code></pre>"},{"location":"api/quantum_cipher_api/","title":"API Reference: Quantum Cipher","text":"<p>This document provides a technical reference for the <code>Quantum Cipher</code> signal generation module. This module is responsible for calculating momentum, volume, and trend-based signals.</p>"},{"location":"api/quantum_cipher_api/#core-logic","title":"Core Logic","text":"<p>The Quantum Cipher combines several standard indicators into a single, cohesive signal: 1.  An Adaptive Momentum Oscillator to gauge the speed and direction of price changes. 2.  A Volume-Weighted Confirmation using VWAP and a volume spike ratio to ensure conviction. 3.  A Dual EMA Trend Filter to ensure signals are only taken in the direction of the prevailing trend.</p>"},{"location":"api/quantum_cipher_api/#functions","title":"Functions","text":""},{"location":"api/quantum_cipher_api/#calculate_quantum_cipherdf","title":"<code>calculate_quantum_cipher(df)</code>","text":"<p>Calculates the full set of Quantum Cipher signals from a market data DataFrame.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>df</code> (pandas.DataFrame): A DataFrame containing OHLCV data with the following columns: <code>timestamp</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>, <code>volume</code>.</li> </ul> </li> <li> <p>Returns: (pandas.DataFrame)</p> <ul> <li>A new DataFrame with the original OHLCV data plus several calculated columns, including:<ul> <li><code>vwap</code>: The Volume-Weighted Average Price.</li> <li><code>osc</code>: The final Momentum Oscillator value.</li> <li><code>buy_signal</code> (bool): <code>True</code> if a buy signal is generated for a given candle.</li> <li><code>sell_signal</code> (bool): <code>True</code> if a sell signal is generated for a given candle.</li> </ul> </li> </ul> </li> <li> <p>Usage Example: <pre><code>import pandas as pd\nfrom app.logic.cipher import fetch_market_data, calculate_quantum_cipher\n\n# 1. Fetch market data\nmarket_df = fetch_market_data('binance', 'BTC/USDT', '1h')\n\n# 2. Calculate signals\nif not market_df.empty:\n    signals_df = calculate_quantum_cipher(market_df)\n    print(signals_df[['timestamp', 'close', 'buy_signal', 'sell_signal']].tail())\n</code></pre></p> </li> </ul>"},{"location":"api/quantum_cipher_api/#fetch_market_dataexchange-symbol-timeframe-limit1000","title":"<code>fetch_market_data(exchange, symbol, timeframe, limit=1000)</code>","text":"<p>Fetches historical OHLCV data from a specified cryptocurrency exchange using the <code>ccxt</code> library.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>exchange</code> (str): The ID of the exchange (e.g., <code>'binance'</code>).</li> <li><code>symbol</code> (str): The trading pair symbol (e.g., <code>'BTC/USDT'</code>).</li> <li><code>timeframe</code> (str): The candle timeframe (e.g., <code>'15m'</code>, <code>'1h'</code>, <code>'1d'</code>).</li> <li><code>limit</code> (int, optional): The number of candles to fetch. Defaults to <code>1000</code>.</li> </ul> </li> <li> <p>Returns: (pandas.DataFrame)</p> <ul> <li>A DataFrame containing the requested OHLCV data.</li> </ul> </li> </ul>"},{"location":"api/quantum_cipher_api/#full-source-code","title":"Full Source Code","text":"Click to view the full source code for `cipher.py` <pre><code>import pandas as pd\nimport numpy as np\nimport ccxt\nimport time\n\ndef calculate_quantum_cipher(df):\n    \"\"\"\n    Calculate Quantum Cipher signals from market data\n    \"\"\"\n    # 1. Calculate core price values\n    df['hlc3'] = (df['high'] + df['low'] + df['close']) / 3\n\n    # 2. Adaptive Momentum Oscillator\n    df['mom'] = df['hlc3'].diff()\n    df['abs_mom'] = df['mom'].abs()\n    df['smooth_mom'] = df['mom'].ewm(span=14, adjust=False).mean()\n    df['smooth_abs'] = df['abs_mom'].ewm(span=14, adjust=False).mean()\n    df['osc'] = 100 * df['smooth_mom'] / (df['smooth_abs'] + 1e-9) # Avoid division by zero\n\n    # 3. Volume-Weighted Confirmation\n    cumulative_vp = (df['hlc3'] * df['volume']).cumsum()\n    cumulative_vol = df['volume'].cumsum()\n    df['vwap'] = cumulative_vp / (cumulative_vol + 1e-9) # Avoid division by zero\n    df['volume_sma20'] = df['volume'].rolling(window=20).mean()\n    df['v_ratio'] = df['volume'] / (df['volume_sma20'] + 1e-9) # Avoid division by zero\n\n    # 4. Trend Filter\n    df['ema_fast'] = df['close'].ewm(span=8, adjust=False).mean()\n    df['ema_slow'] = df['close'].ewm(span=21, adjust=False).mean()\n\n    # 5. Signal Conditions\n    df['bull_vol'] = (df['close'] &gt; df['vwap']\n&lt;/details&gt;\n</code></pre>"},{"location":"api/quantum_volume_profile_api/","title":"API Reference: Quantum Volume Profile","text":"<p>This document provides a technical reference for the <code>QuantumVolumeProfile</code> class. This class is an enhanced volume profile analyzer that provides deep insights into market structure, value areas, and key support/resistance levels.</p>"},{"location":"api/quantum_volume_profile_api/#core-logic","title":"Core Logic","text":"<p>The <code>QuantumVolumeProfile</code> class is a stateful analyzer that processes market data bar-by-bar to build a volume profile over a dynamic range. Its key features include:</p> <ul> <li>Dynamic Range Selection: Can build profiles for a single session, a rolling window, or a fixed anchor date.</li> <li>Key Level Calculation: Automatically identifies the Point of Control (POC), Value Area (VAL/VAH), High Volume Nodes (HVN), and Low Volume Nodes (LVN).</li> <li>Signal Generation: Provides actionable trading signals based on the price's relationship to the calculated volume profile levels.</li> </ul>"},{"location":"api/quantum_volume_profile_api/#class-quantumvolumeprofile","title":"Class: <code>QuantumVolumeProfile</code>","text":""},{"location":"api/quantum_volume_profile_api/#__init__self-range_typesession-window20-anchor_datenone","title":"<code>__init__(self, range_type='session', window=20, anchor_date=None)</code>","text":"<p>Initializes the volume profile analyzer.</p> <ul> <li>Parameters:<ul> <li><code>range_type</code> (str): The type of profile to build. Can be <code>'session'</code>, <code>'rolling'</code>, <code>'anchor'</code>, or <code>'visible'</code>.</li> <li><code>window</code> (int): The number of bars for a <code>'rolling'</code> profile.</li> <li><code>anchor_date</code> (datetime, optional): The start date for an <code>'anchor'</code> profile.</li> </ul> </li> </ul>"},{"location":"api/quantum_volume_profile_api/#update_profileself-bar_data","title":"<code>update_profile(self, bar_data)</code>","text":"<p>Updates the profile with a new bar of market data.</p> <ul> <li>Parameters:<ul> <li><code>bar_data</code> (dict or pandas.Series): A dictionary or Series containing OHLCV data for a single bar, including <code>timestamp</code>, <code>high</code>, <code>low</code>, and <code>volume</code>.</li> </ul> </li> </ul>"},{"location":"api/quantum_volume_profile_api/#get_profile_summaryself","title":"<code>get_profile_summary(self)</code>","text":"<p>Returns a dictionary containing a comprehensive summary of the current profile state.</p> <ul> <li>Returns: (dict)<ul> <li>A dictionary with keys like <code>poc_price</code>, <code>val</code>, <code>vah</code>, <code>hvn_count</code>, <code>lvn_count</code>, etc.</li> </ul> </li> </ul>"},{"location":"api/quantum_volume_profile_api/#get_signalsself-current_price-current_volume","title":"<code>get_signals(self, current_price, current_volume)</code>","text":"<p>Generates a list of trading signals based on the current price's position relative to the volume profile.</p> <ul> <li>Parameters:<ul> <li><code>current_price</code> (float): The current market price.</li> <li><code>current_volume</code> (float): The volume of the current bar.</li> </ul> </li> <li> <p>Returns: (list)</p> <ul> <li>A list of strings representing active signals (e.g., <code>['VAH_BREAKOUT', 'REVERSION_TO_POC']</code>).</li> </ul> </li> <li> <p>Usage Example: <pre><code>from app.logic.volume_profile import QuantumVolumeProfile\nimport pandas as pd\n\n# Initialize for a daily session profile\nqvp = QuantumVolumeProfile(range_type='session')\n\n# Assume 'market_data_df' is a DataFrame with historical data\nfor index, bar in market_data_df.iterrows():\n    # Update the profile with each new bar\n    qvp.update_profile(bar)\n\n    # Check for signals\n    signals = qvp.get_signals(bar['close'], bar['volume'])\n    if signals:\n        print(f\"Time: {bar['timestamp']}, Signals: {signals}\")\n\n# Get a summary at the end of the session\nsummary = qvp.get_profile_summary()\nprint(\"Session Summary:\", summary)\n</code></pre></p> </li> </ul>"},{"location":"api/quantum_volume_profile_api/#full-source-code","title":"Full Source Code","text":"Click to view the full source code for `volume_profile.py` <pre><code>import pandas as pd\nimport numpy as np\nfrom collections import defaultdict\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\nclass QuantumVolumeProfile:\n    def __init__(self, range_type='session', window=20, anchor_date=None):\n        self.range_type = range_type\n        self.window = window\n        self.anchor_date = anchor_date\n        self.profile = defaultdict(float)\n        self.total_volume = 0.0\n        self.poc_price = None\n        self.poc_volume = 0.0\n        self.val = None\n        self.vah = None\n        self.hvn = []\n        self.lvn = []\n        self.last_bar_time = None\n\n    def reset_profile(self):\n        self.profile = defaultdict(float)\n        self.total_volume = 0.0\n        # ... reset other attributes\n\n    def _should_reset(self, bar_time):\n        if self.range_type == 'session':\n            if self.last_bar_time is None:\n                return True\n            return bar_time.date() != self.last_bar_time.date()\n        return False\n\n    def update_profile(self, bar_data):\n        timestamp = pd.to_datetime(bar_data['timestamp'])\n        high = float(bar_data['high'])\n        low = float(bar_data['low'])\n        volume = float(bar_data['volume'])\n\n        if self._should_reset(timestamp):\n            self.reset_profile()\n\n        price_range = np.linspace(low, high, num=int((high - low) / 0.5) + 1) # Example resolution\n        vol_per_price = volume / len(price_range) if price_range.size &gt; 0 else 0\n\n        for price in price_range:\n            price_level = round(price * 2) / 2 # Round to nearest 0.5\n            self.profile[price_level] += vol_per_price\n            self.total_volume += vol_per_price\n\n        self.last_bar_time = timestamp\n        self._calculate_metrics()\n\n    def _calculate_metrics(self):\n        if not self.profile:\n            return\n\n        prices = np.array(sorted(self.profile.keys()))\n        volumes = np.array([self.profile[p] for p in prices])\n\n        # 1. Find POC\n        poc_idx = np.argmax(volumes)\n        self.poc_price = prices[poc_idx]\n        self.poc_volume = volumes[poc_idx]\n\n        # 2. Calculate Value Area (70%)\n        sorted_indices = np.argsort(volumes)[::-1]\n        cumulative_vol = 0\n        value_area_indices = []\n        for idx in sorted_indices:\n            cumulative_vol += volumes[idx]\n            value_area_indices.append(idx)\n            if cumulative_vol &gt;= self.total_volume * 0.7:\n                break\n        value_area_prices = prices[value_area_indices]\n        self.val = np.min(value_area_prices)\n        self.vah = np.max(value_area_prices)\n\n        # 3. Identify HVN/LVN (statistical approach)\n        mean_vol = np.mean(volumes)\n        std_vol = np.std(volumes)\n        self.hvn = prices[volumes &gt; mean_vol + 1.5 * std_vol].tolist()\n        self.lvn = prices[volumes &lt; mean_vol - 0.5 * std_vol].tolist()\n\n    def get_profile_summary(self):\n        return {\n            'poc_price': self.poc_price,\n            'val': self.val,\n            'vah': self.vah,\n            # ... other summary data\n        }\n\n    def get_signals(self, current_price, current_volume):\n        signals = []\n        # Signal logic based on price relative to POC, VAL, VAH, HVNs, LVNs\n        # (Example)\n        if current_price &gt; self.vah and current_volume &gt; self.poc_volume * 0.5:\n             signals.append(\"VAH_BREAKOUT_CONFIRMED\")\n        return signals\n&lt;/details&gt;\n</code></pre>"},{"location":"architecture/ai_orchestration/","title":"The AI Learning System","text":"<p>To enable the AI trading system to learn, adapt, and improve its performance over time, we use a continuous feedback loop. This document outlines the key components and processes involved.</p>"},{"location":"architecture/ai_orchestration/#core-components-for-learning","title":"Core Components for Learning","text":"<p>For the AI to analyze and improve, it needs access to several key data sources:</p> Data Source Purpose Exchange APIs (Binance, Bybit) Real-time price data, order execution history. On-Chain Data (Etherscan) Wallet tracking, smart contract events. Market Intelligence (Glassnode) Market sentiment, liquidity data, on-chain analytics. News/Sentiment APIs (CryptoPanic) Event detection and news-driven sentiment analysis."},{"location":"architecture/ai_orchestration/#the-feedback-loop","title":"The Feedback Loop","text":"<p>The core of the learning process is a cycle where the results of past trades are used to improve future decisions.</p> <pre><code>graph LR\n    A[Trade Execution] --&gt; B{Performance Metrics};\n    B --&gt; C[Win/Loss &amp; Slippage Analysis];\n    C --&gt; D[AI Strategy Adjuster];\n    D --&gt; E[Model Retraining &amp; Validation];\n    E --&gt; A;</code></pre> <p>This loop consists of: Trade Execution: A trade is made based on the current AI model. Performance Metrics: The outcome of the trade (profit, loss, slippage, fees) is recorded. Analysis: The system analyzes why the trade succeeded or failed, considering the market conditions at the time. Strategy Adjustment: The AI model proposes adjustments to its internal parameters or rules. Retraining: The model is retrained with the new data and validated against historical data before being deployed. Reinforcement Learning Parameters To guide its learning, the AI uses a set of high-level goals and risk parameters. These act as its \"personality\" and strategic objectives.</p> <pre><code>{\n  \"risk_parameters\": {\n    \"max_drawdown_percent\": 15,\n    \"daily_loss_limit_percent\": 5\n  },\n  \"learning_goals\": {\n    \"target_sharpe_ratio\": 2.5,\n    \"win_rate_improvement_goal\": \"5% quarterly\"\n  },\n  \"personality_profile\": {\n    \"trading_style\": \"swing_trader\",\n    \"fomo_resistance\": \"medium\"\n  }\n}</code></pre> <p>By providing these elements, the AI can learn your historical decision patterns, adapt to your risk tolerance, and continuously refine its strategies to discover new market opportunities. code.</p>"},{"location":"architecture/real_time_data_flow/","title":"Full Setup: Real-Time Architecture in Codespaces","text":"<p>This document outlines the exact steps to set up the full development environment in GitHub Codespaces to support the entire real-time application stack.</p>"},{"location":"architecture/real_time_data_flow/#overview","title":"Overview","text":"<p>This tutorial covers:</p> <ul> <li>\u26a1 Real-time AI signal generation</li> <li>\ud83c\udf10 FastAPI + Socket.IO WebSocket backend</li> <li>\ud83d\udd01 React frontend with a WebSocket client</li> <li>\ud83d\udd27 A complete, containerized dev environment for scalability</li> </ul>"},{"location":"architecture/real_time_data_flow/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have completed the 5-Minute Quickstart.</li> <li>You have a basic understanding of Docker and <code>docker-compose</code>.</li> </ul>"},{"location":"architecture/real_time_data_flow/#1-project-structure-required-layout","title":"1. Project Structure (Required Layout)","text":"<p>For the system to work correctly, your repository must follow this structure:</p> <p>quantum-trader/ \u251c\u2500\u2500 .devcontainer/ \u2502 \u2514\u2500\u2500 devcontainer.json \u251c\u2500\u2500 docker-compose.yml \u251c\u2500\u2500 backend/ \u2502 \u251c\u2500\u2500 main.py \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u2514\u2500\u2500 app/ \u2502 \u2514\u2500\u2500 logic/ \u2502 \u2514\u2500\u2500 cipher.py \u2514\u2500\u2500 frontend/ \u251c\u2500\u2500 index.html \u251c\u2500\u2500 main.jsx \u2514\u2500\u2500 package.json</p>"},{"location":"architecture/real_time_data_flow/#2-configure-codespaces-devcontainerdevcontainerjson","title":"2. Configure Codespaces: <code>.devcontainer/devcontainer.json</code>","text":"<p>This file defines the development container, telling Codespaces how to build the environment.</p> <pre><code>{\n  \"name\": \"quantum-trader-dev\",\n  \"dockerComposeFile\": \"docker-compose.yml\",\n  \"service\": \"backend\",\n  \"workspaceFolder\": \"/workspace/backend\",\n  \"settings\": {\n    \"terminal.integrated.shell.linux\": \"/bin/bash\"\n  },\n  \"extensions\": [\n    \"ms-python.python\",\n    \"ms-azuretools.vscode-docker\",\n    \"esbenp.prettier-vscode\"\n  ],\n  \"postCreateCommand\": \"pip install -r requirements.txt\"\n}\n</code></pre> <ol> <li>Container Composition: docker-compose.yml</li> </ol> <p>This file orchestrates all the services required for the application: the Python backend, the React frontend, and the Redis cache.</p> <pre><code>services:\n  backend:\n    build:\n      context: ./backend\n    container_name: fastapi_app\n    ports:\n      - \"8000:8000\"\n    volumes:\n      - ./backend:/workspace/backend\n    depends_on:\n      - redis\n    environment:\n      - REDIS_URL=redis://redis:6379\n    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload\n\n  redis:\n    image: redis:7-alpine\n    container_name: redis_cache\n    ports:\n      - \"6379:6379\"\n\n  frontend:\n    build:\n      context: ./frontend\n    container_name: react_ui\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - ./frontend:/app\n    command: npm run dev\n</code></pre> <ol> <li>FastAPI App Setup (with WebSocket)</li> </ol> <p>The core of the backend is the main.py file, which sets up the FastAPI application and the Socket.IO manager for real-time communication.</p> <pre><code># located in backend/main.py\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi_socketio import SocketManager\nimport pandas as pd\n\nfrom app.logic.cipher import fetch_market_data, calculate_quantum_cipher\n\napp = FastAPI(title=\"Quantum Trader Pro API\")\nsio = SocketManager(app=app)\n\n# CORS for dev\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.get(\"/\")\ndef health_check():\n    return {\"status\": \"OK\", \"message\": \"Quantum Trader Pro Backend is Live!\"}\n\n@sio.on('connect')\nasync def connect(sid, environ):\n    print(f\"[WebSocket] Client connected: {sid}\")\n    await sio.emit('message', {'message': 'Connected to Quantum Trader WS'}, to=sid)\n\n@app.get(\"/ws-test\")\nasync def test_socket():\n    await sio.emit(\"new_signal\", {\"type\": \"test\", \"data\": \"\ud83d\udea8 Test signal from backend!\"})\n    return {\"status\": \"Signal emitted\"}\n</code></pre> <p>This setup provides a health check endpoint, a WebSocket connection handler, and a test route to verify that real-time messages can be sent.</p>"},{"location":"architecture/system_overview/","title":"System Architecture","text":"<p>This document provides a high-level overview of the Quantum Trader Pro architecture, its core components, and the technology stack.</p>"},{"location":"architecture/system_overview/#core-philosophy-a-hybrid-approach","title":"Core Philosophy: A Hybrid Approach","text":"<p>The system is built on a hybrid model that balances speed of development with granular control over critical components:</p> <ul> <li>AI Builders for UI &amp; Admin: A platform like Dify.ai or Bubble can be used to rapidly develop the user interface, dashboards, and administrative panels. This handles 80% of the standard web application features.</li> <li>Custom Python Backend for Trading Logic: The core trading engine, signal processing, and AI strategy generation are written in custom Python to ensure maximum performance, control, and flexibility.</li> </ul> <p>This approach allows for a fast, iterative development cycle for the user-facing parts of the app while reserving deep, custom engineering for the mission-critical trading core.</p>"},{"location":"architecture/system_overview/#high-level-flow","title":"High-Level Flow","text":"<p>The data and command flow through the system is designed to be decoupled and scalable.</p> <pre><code>graph LR\n    A[UI / AI Builder] --&gt; B[API Gateway / FastAPI];\n    B --&gt; C{Trading Logic Router};\n    C --&gt; D[Quantum Cipher Engine];\n    C --&gt; E[Quantum Volume Profile];\n    C --&gt; F[AI Strategy Generator];\n    D &amp; E &amp; F --&gt; G[Signal Confirmation];\n    G --&gt; H[Execution Service];\n    H --&gt; I[Exchange APIs];</code></pre> <p>Technology Stack The system leverages a modern, robust set of tools and services, categorized by their function. \ud83e\udde0 AI &amp; Prompt Engineering Gemini Build (Google AI): AI copilot for building the application. LLM APIs (Gemini, Mixtral): Used for conversational assistance and strategy generation. LangChain: The framework for building and orchestrating AI agents. \ud83d\udcbb Backend &amp; Development FastAPI: High-performance Python framework for the API backend. Redis: In-memory data store for caching and real-time Pub/Sub messaging. Socket.IO: Enables real-time, bidirectional communication with the frontend. Docker / Docker Compose: Containerizes all services for a reproducible and scalable environment. GitHub Codespaces: Cloud-based development environment. \u269b\ufe0f Frontend React: The primary UI framework for building interactive components. Vite or Next.js: Modern frontend tooling for building and serving the UI. \ud83d\udcca Data &amp; Infrastructure TimescaleDB: A time-series database (PostgreSQL extension) for storing market data. Kafka (Optional): Can be added later as a scalable message bus for high-throughput data pipelines.</p>"},{"location":"backend/fastapi_structure/","title":"FastAPI Application Structure","text":"<p>This document outlines the standard file and folder structure for the Python backend, built with the FastAPI framework. Adhering to this structure ensures the project is organized, scalable, and easy to maintain.</p> <p>Audience: You (Infrastructure), Gemini (API Logic) Goal: To provide a clear map for where to place new files, routes, and business logic.</p>"},{"location":"backend/fastapi_structure/#backend-directory-layout","title":"Backend Directory Layout","text":"<p>The <code>backend/</code> directory will contain all Python source code, dependencies, and worker scripts.</p> <p>backend/ \u251c\u2500\u2500 app/ \u2502 \u251c\u2500\u2500 init.py \u2502 \u251c\u2500\u2500 api/ \u2502 \u2502 \u251c\u2500\u2500 init.py \u2502 \u2502 \u251c\u2500\u2500 v1/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 init.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 endpoints/ \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 init.py \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 signals.py # Handles /signals/... routes \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 ai.py # Handles /ai/... routes \u2502 \u2502 \u2502 \u2514\u2500\u2500 api.py # Main v1 router \u2502 \u251c\u2500\u2500 logic/ \u2502 \u2502 \u251c\u2500\u2500 init.py \u2502 \u2502 \u251c\u2500\u2500 quantum_cipher.py # Core logic for Quantum Cipher \u2502 \u2502 \u2514\u2500\u2500 quantum_volume.py # Core logic for Volume Profile \u2502 \u251c\u2500\u2500 services/ \u2502 \u2502 \u251c\u2500\u2500 init.py \u2502 \u2502 \u251c\u2500\u2500 redis_service.py # Handles all Redis interactions \u2502 \u2502 \u2514\u2500\u2500 websocket_manager.py # Manages WebSocket connections \u2502 \u2514\u2500\u2500 workers/ \u2502 \u251c\u2500\u2500 init.py \u2502 \u2514\u2500\u2500 signal_monitor.py # Background worker for real-time signals \u2502 \u251c\u2500\u2500 tests/ \u2502 \u251c\u2500\u2500 init.py \u2502 \u2514\u2500\u2500 test_api.py \u2502 \u251c\u2500\u2500 .env.example # Example environment file \u251c\u2500\u2500 Dockerfile # Instructions to build the backend container \u251c\u2500\u2500 main.py # Main application entry point \u2514\u2500\u2500 requirements.txt # Python dependencies</p>"},{"location":"backend/fastapi_structure/#core-components-explained","title":"Core Components Explained","text":"<ul> <li><code>main.py</code>: The root of the application. It initializes the FastAPI app, includes the main API router, sets up middleware (like CORS), and defines startup/shutdown events.</li> <li><code>app/api/v1/</code>: This is the versioned API module.<ul> <li><code>endpoints/</code>: Each file here represents a group of related API endpoints (e.g., <code>signals.py</code> for all signal-related routes).</li> <li><code>api.py</code>: This file aggregates all the endpoint routers from the <code>endpoints/</code> directory into a single main router for <code>/api/v1</code>.</li> </ul> </li> <li><code>app/logic/</code>: Contains the \"pure\" business logic. These are Python scripts that perform calculations (like our signal indicators) and do not depend on the web framework. This makes them highly reusable and testable.</li> <li><code>app/services/</code>: Contains modules that interact with external services like Redis or manage persistent connections like WebSockets.</li> <li><code>app/workers/</code>: Contains standalone scripts designed to be run as long-running background processes (e.g., in a separate Docker container).</li> </ul>"},{"location":"backend/fastapi_structure/#execution-flow-for-an-api-request","title":"Execution Flow for an API Request","text":"<ol> <li>A request hits <code>main.py</code>.</li> <li>FastAPI routes it to the main router in <code>app/api/v1/api.py</code>.</li> <li>The v1 router passes it to the specific endpoint function in a file within <code>app/api/v1/endpoints/</code>.</li> <li>The endpoint function calls a \"logic\" or \"service\" module to perform the actual work.</li> <li>The result is returned as a JSON response.</li> </ol>"},{"location":"backend/redis_pubsub/","title":"Redis Pub/Sub Architecture","text":"<p>This document outlines the use of Redis Pub/Sub as the central message bus for the backend. This architecture allows for a decoupled system where different services can communicate asynchronously.</p> <p>Audience: You (Infrastructure), Gemini (Implementation) Goal: To define the channels and data flow for inter-service communication.</p>"},{"location":"backend/redis_pubsub/#core-concept","title":"Core Concept","text":"<p>The system uses a Publish-Subscribe pattern.</p> <ul> <li>Publishers: Services that generate data (like the <code>signal_monitor.py</code> worker) will \"publish\" messages to a specific Redis channel. They don't know or care who is listening.</li> <li>Subscribers: Services that need to react to data (like the main FastAPI server) will \"subscribe\" to those channels and listen for messages.</li> </ul> <p>This prevents the web server from being blocked by long-running tasks like constantly polling a market data API.</p>"},{"location":"backend/redis_pubsub/#high-level-data-flow","title":"High-Level Data Flow","text":"<pre><code>graph TD\n    A[Signal Monitor Worker] --&gt; B(Calculates Signal);\n    B --&gt; C{{Redis}};\n    C -- \"Publishes to 'quantum_signals' channel\" --&gt; C;\n    D[FastAPI Server] -- \"Subscribes to 'quantum_signals'\" --&gt; C;\n    D --&gt; E(Receives Signal from Redis);\n    E --&gt; F[WebSocket Manager];\n    F -- \"Emits 'new_signal' event\" --&gt; G((Connected Clients));</code></pre> <p>Implementation Details 1. The Publisher (signal_monitor.py) The background worker is responsible for publishing new signals. Library: Standard redis-py library. Action: Connect to the Redis instance. In a loop, fetch market data and calculate signals. If a new signal is found, serialize the signal data to a JSON string. Use the r.publish('quantum_signals', json_string) command to send the data to the quantum_signals channel. Example Code Snippet:</p> <pre><code># In app/workers/signal_monitor.py\nimport redis\nimport json\nimport time\nimport os\n\nr = redis.Redis.from_url(os.getenv(\"REDIS_URL\"))\n\ndef monitor_market():\n    while True:\n        # ... logic to calculate signal ...\n        new_signal_found = True # Placeholder for actual logic\n        if new_signal_found:\n            signal_data = { \"type\": \"BUY\", \"price\": 60000 }\n            r.publish('quantum_signals', json.dumps(signal_data))\n            print(\"Published signal to Redis.\")\n        time.sleep(60)\n</code></pre> <ol> <li>The Subscriber (FastAPI main.py) The main web application will listen for these messages in a background task. Library: redis.asyncio to work seamlessly with FastAPI's async nature. Action: On application startup (@app.on_event(\"startup\")), create a background task that runs a listener function. The listener function subscribes to the quantum_signals channel. It enters an infinite loop, waiting for messages. When a message is received, it deserializes the JSON data. It then calls the WebSocket manager (sio.emit) to broadcast the data to all connected clients. Example Code Snippet:</li> </ol> <pre><code># In main.py\nimport asyncio\nimport redis.asyncio as redis\nimport os\nimport json\n# Assume 'sio' is your imported websocket manager\n\nredis_client = redis.from_url(os.getenv(\"REDIS_URL\"))\n\nasync def redis_listener():\n    pubsub = redis_client.pubsub()\n    await pubsub.subscribe('quantum_signals')\n    while True:\n        try:\n            message = await pubsub.get_message(ignore_subscribe_messages=True, timeout=1.0)\n            if message and message.get(\"data\"):\n                signal_data = json.loads(message['data'])\n                await sio.emit('new_signal', signal_data)\n        except Exception as e:\n            print(f\"Redis listener error: {e}\")\n            await asyncio.sleep(1)\n\n\n# @app.on_event(\"startup\")\n# async def startup_event():\n#     asyncio.create_task(redis_listener())\n</code></pre>"},{"location":"backend/websocket_service/","title":"WebSocket Service","text":"<p>This document specifies the design and implementation of the real-time WebSocket service, which is responsible for pushing live data and signals to connected frontend clients.</p> <p>Audience: Gemini (Implementation), You (Verification) Goal: Define the exact events and data structures for real-time communication.</p>"},{"location":"backend/websocket_service/#core-technology","title":"Core Technology","text":"<ul> <li>Library: <code>python-socketio</code> integrated with FastAPI via <code>fastapi-socketio</code>.</li> <li>Purpose: To provide a persistent, bidirectional communication channel between the FastAPI backend and the React frontend.</li> </ul>"},{"location":"backend/websocket_service/#service-location","title":"Service Location","text":"<p>All WebSocket connection logic will be managed within a dedicated service module to keep the main <code>main.py</code> file clean.</p> <ul> <li>File: <code>backend/app/services/websocket_manager.py</code></li> <li>Object: A singleton class or object instance named <code>sio</code> (Socket.IO Manager).</li> </ul> <p>This <code>sio</code> object will be initialized in <code>websocket_manager.py</code> and imported into <code>main.py</code> to be attached to the FastAPI application.</p>"},{"location":"backend/websocket_service/#server-side-event-handlers","title":"Server-Side Event Handlers","text":"<p>The <code>sio</code> manager must implement handlers for the following standard events.</p>"},{"location":"backend/websocket_service/#connect","title":"<code>connect</code>","text":"<ul> <li>Trigger: A new client establishes a WebSocket connection.</li> <li>Action:<ol> <li>Log the connection with the client's unique Session ID (<code>sid</code>).</li> <li>Emit a <code>'welcome'</code> message back to the connected client to confirm the connection was successful.</li> </ol> </li> <li>Example Implementation: <pre><code># In websocket_manager.py\nimport socketio\n\nsio = socketio.AsyncServer(async_mode='asgi', cors_allowed_origins='*')\n\n@sio.event\nasync def connect(sid, environ):\n    print(f\"[Socket.IO] Client connected: {sid}\")\n    await sio.emit('welcome', {'message': 'Successfully connected to Quantum Trader Pro real-time feed.'}, to=sid)\n</code></pre></li> </ul>"},{"location":"backend/websocket_service/#disconnect","title":"<code>disconnect</code>","text":"<ul> <li>Trigger: A client disconnects.</li> <li>Action:<ol> <li>Log the disconnection event with the client's <code>sid</code>.</li> </ol> </li> <li>Example Implementation: <pre><code>@sio.event\ndef disconnect(sid):\n    print(f\"[Socket.IO] Client disconnected: {sid}\")\n</code></pre></li> </ul>"},{"location":"backend/websocket_service/#emitted-events-server-to-client","title":"Emitted Events (Server to Client)","text":"<p>The server will proactively push data to all connected clients using these custom events.</p>"},{"location":"backend/websocket_service/#new_signal","title":"<code>new_signal</code>","text":"<ul> <li>Trigger: A new trading signal is generated by the backend (e.g., from the Redis Pub/Sub listener).</li> <li>Payload (Data Structure): A JSON object with a consistent structure.     <pre><code>{\n  \"type\": \"QUANTUM_CIPHER\",\n  \"signal\": \"BUY\" or \"SELL\",\n  \"price\": 162.50,\n  \"symbol\": \"BTC/USDT\",\n  \"timeframe\": \"1m\",\n  \"timestamp\": \"2023-10-27T10:00:00Z\"\n}\n</code></pre></li> <li>Action: The server broadcasts this payload to all connected clients using <code>await sio.emit('new_signal', data)</code>.</li> </ul>"},{"location":"backend/websocket_service/#status_update","title":"<code>status_update</code>","text":"<ul> <li>Trigger: A change in the backend's operational status.</li> <li>Payload (Data Structure): <pre><code>{\n  \"service\": \"SignalMonitorWorker\",\n  \"status\": \"active\" or \"degraded\" or \"offline\",\n  \"message\": \"Monitoring market for signals.\"\n}\n</code></pre></li> <li>Action: Broadcast the status update to all clients.</li> </ul>"},{"location":"deployment/security_checklist/","title":"Configuration &amp; API Keys","text":"<p>Quantum Trader Pro requires API keys and other secrets to connect to exchanges and data providers. To handle these securely, the project uses a <code>.env</code> file.</p> <p>Never Commit Your Secrets</p> <p>The <code>.env</code> file should NEVER be committed to Git or shared publicly. It contains your private credentials. The project's <code>.gitignore</code> file is already configured to ignore this file, but you must always be vigilant.</p>"},{"location":"deployment/security_checklist/#how-to-set-up-your-configuration","title":"How to Set Up Your Configuration","text":"<ol> <li> <p>Create the File: In the root directory of the project, create a new file named <code>.env</code>.</p> </li> <li> <p>Add Your Keys: Open the <code>.env</code> file and add your keys in the <code>KEY=VALUE</code> format. Below is a sample structure you can use as a template.</p> <pre><code># --- Exchange APIs ---\n# Used for fetching market data and executing trades\nBINANCE_API_KEY=your_binance_api_key_here\nBINANCE_API_SECRET=your_binance_api_secret_here\n\n# --- Data Provider APIs ---\n# (Optional) For additional market data or analytics\nCOINMARKETCAP_API_KEY=your_coinmarketcap_api_key\n\n# --- Notification Systems ---\n# (Optional) For sending alerts\nTELEGRAM_BOT_TOKEN=your_bot_token\nTELEGRAM_CHAT_ID=your_chat_id\n\n# --- Internal Connections ---\n# This is pre-configured for Docker, no need to change for local dev\nREDIS_URL=redis://redis:6379\n</code></pre> </li> </ol>"},{"location":"deployment/security_checklist/#how-the-application-uses-these-keys","title":"How the Application Uses These Keys","text":"<p>The Python backend (FastAPI) and various scripts will automatically load these variables from your <code>.env</code> file when the application starts. You do not need to hardcode them anywhere in the application logic.</p>"},{"location":"frontend/react_structure/","title":"React Application Structure","text":"<p>This document outlines the standard file and folder structure for the React frontend application, which was initially scaffolded by Gemini Build. This structure promotes a clean, component-based architecture.</p> <p>Audience: You (Frontend Dev), Gemini (UI Components) Goal: To maintain a consistent and organized structure for the user interface code.</p>"},{"location":"frontend/react_structure/#frontend-directory-layout-frontendsrc","title":"Frontend Directory Layout (<code>frontend/src/</code>)","text":"<p>All frontend source code resides within the <code>src/</code> directory.</p> <p>src/ \u251c\u2500\u2500 App.tsx # Main application component, handles routing \u2502 \u251c\u2500\u2500 components/ \u2502 \u251c\u2500\u2500 shared/ # Small, reusable components used everywhere \u2502 \u2502 \u251c\u2500\u2500 Card.tsx \u2502 \u2502 \u251c\u2500\u2500 MarketChart.tsx \u2502 \u2502 \u2514\u2500\u2500 Spinner.tsx \u2502 \u2502 \u2502 \u251c\u2500\u2500 Header.tsx # The top navigation bar \u2502 \u2514\u2500\u2500 Sidebar.tsx # The main left-hand navigation menu \u2502 \u251c\u2500\u2500 views/ # Top-level page components (the \"screens\") \u2502 \u251c\u2500\u2500 DashboardView.tsx # Main market dashboard with charts \u2502 \u251c\u2500\u2500 PortfolioView.tsx # Displays user's portfolio and equity \u2502 \u251c\u2500\u2500 TradingView.tsx # The trading terminal for buys/sells \u2502 \u2514\u2500\u2500 AnalysisView.tsx # The AI Analysis Center \u2502 \u251c\u2500\u2500 hooks/ # Custom React hooks for shared logic \u2502 \u2514\u2500\u2500 usePortfolio.ts # Example: hook to manage portfolio state \u2502 \u251c\u2500\u2500 services/ # Modules for interacting with APIs \u2502 \u2514\u2500\u2500 geminiService.ts # Functions for calling AI backend endpoints \u2502 \u251c\u2500\u2500 constants.ts # App-wide constants (e.g., API URLs) \u2514\u2500\u2500 types.ts # TypeScript type definitions (e.g., Portfolio, Trade)</p>"},{"location":"frontend/react_structure/#core-components-explained","title":"Core Components Explained","text":"<ul> <li> <p><code>App.tsx</code>: The root component of the application. Its primary job is to set up the main layout (e.g., Sidebar + Main Content area) and handle the client-side routing between different <code>views</code>.</p> </li> <li> <p><code>components/</code>: This directory holds all the reusable UI building blocks.</p> <ul> <li><code>shared/</code>: Contains highly generic components that can be used on any page, such as a styled <code>Card</code>, a <code>Spinner</code> for loading states, or a generic <code>MarketChart</code>.</li> <li>Larger, more specific components like the <code>Header</code> and <code>Sidebar</code> live at the top level of <code>components/</code>.</li> </ul> </li> <li> <p><code>views/</code>: Each file in this directory represents a full \"page\" or \"screen\" in the application. These components are responsible for the layout of a specific page and typically compose smaller components from the <code>components/</code> directory. For example, <code>DashboardView.tsx</code> would import and use multiple <code>MarketChart</code> components.</p> </li> <li> <p><code>hooks/</code>: Custom React hooks provide a way to extract and reuse stateful logic. For example, a <code>usePortfolio</code> hook could contain all the logic for fetching, updating, and managing the user's portfolio data, which can then be easily used in both <code>PortfolioView.tsx</code> and <code>TradingView.tsx</code>.</p> </li> <li> <p><code>services/</code>: This is the data layer of the frontend. It contains functions that handle all external API calls. This decouples the UI components from the specifics of <code>fetch</code> or <code>axios</code>, making the code cleaner and easier to test.</p> </li> </ul> <p>This organized structure makes it easy to locate code, manage state, and scale the application by adding new views and components in a predictable way.</p>"},{"location":"getting-started/introduction/","title":"Introduction","text":"<p>Project Mission: To create an institutional-grade crypto trading platform that combines human-guided strategy with AI-powered analysis and execution.</p> <p>This project is built on the philosophy of a \"Mutual Build Map\", where the documentation serves as a shared contract between the human developer (the Architect) and the AI development partner (the Builder).</p>"},{"location":"getting-started/introduction/#the-core-roles","title":"The Core Roles","text":"<ul> <li>The Architect (You): Responsible for high-level strategy, infrastructure, security, and final deployment. You define what to build and why.</li> <li>The Builder (AI Partner - Gemini Build): Responsible for executing the plan. It writes the code for UI components, API endpoints, and business logic based on the clear specifications laid out in this documentation.</li> </ul> <p>This \"Docs-Driven AI Development\" workflow allows for rapid iteration, high-quality code, and a clear, shared understanding of the entire system.</p> <p>Every new feature begins its life here, in the documentation, before a single line of code is written by the AI.</p>"},{"location":"getting-started/quickstart/","title":"Getting Started in 5 Minutes","text":"<p>This guide will take you from zero to a fully running Quantum Trader Pro environment, right in your browser.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>A GitHub Account.</li> <li>GitHub Codespaces enabled for your account.</li> </ul>"},{"location":"getting-started/quickstart/#step-1-open-the-project-in-codespaces","title":"Step 1: Open the Project in Codespaces","text":"<p>This is the easiest step. On the main page of the GitHub repository, click the green <code>&lt; &gt; Code</code> button, navigate to the Codespaces tab, and click \"Create codespace on main\".</p> <p>This will launch a complete, containerized development environment in your browser.</p>"},{"location":"getting-started/quickstart/#step-2-start-all-services","title":"Step 2: Start All Services","text":"<p>Once your Codespace terminal is ready, run the following single command. This will build the Docker containers for the backend, frontend, and Redis, and then start them all up.</p> <pre><code>docker-compose up --build\n</code></pre> <p>You will see a lot of log output as the services start. This is normal.</p> <p>Step 3: Verify Everything is Running</p> <p>The system is now live! GitHub Codespaces automatically forwards the necessary ports.</p> <p>Check the Backend: Open http://localhost:8000 in a new browser tab. You should see {\"status\":\"OK\",\"message\":\"Quantum Trader Pro Backend is Live!\"}.</p> <p>Check the Frontend: Open http://localhost:3000. You'll see the basic \"Quantum Trader Pro UI\".</p> <p>Confirm the Real-Time Connection: With the frontend tab open, check the browser's developer console (usually F12 or Ctrl+Shift+I). You should see the message: \u2705 Connected to WebSocket.</p> <p>\ud83c\udf89 That's it! You now have a live, real-time connection between the frontend and backend.</p> <p>What's Next?</p> <p>Curious how all the pieces fit together? For a detailed explanation of the container setup, WebSocket connections, and real-time architecture, dive into the full tutorial.</p> <p>View the Full Real-Time Setup Tutorial{ .md-button }</p>"},{"location":"getting-started/tools_resources/","title":"Tools, Frameworks &amp; Services","text":"<p>This document provides a comprehensive, categorized list of the tools, platforms, and services used in the Quantum Trader Pro application.</p>"},{"location":"getting-started/tools_resources/#ai-prompt-engineering","title":"\ud83e\udde0 AI &amp; Prompt Engineering","text":"Tool / Service Description Gemini Build (Google AI) AI copilot used for building the application via natural language interfaces. Gemini Pro API External LLM used for conversational assistance and prompt generation. Mixtral 8x7B API High-performance model for internal AI strategy generation. LangChain Framework for building AI agents, managing prompts, memory, and tool usage."},{"location":"getting-started/tools_resources/#development-environment","title":"\ud83d\udcbb Development Environment","text":"Tool / Service Description GitHub Source control, collaboration, CI/CD base. GitHub Codespaces Cloud-based dev environment where the app runs and builds. Docker / Docker Compose Containerized services for reproducible dev environments."},{"location":"getting-started/tools_resources/#backend","title":"\ud83e\udde9 Backend","text":"Tool / Library Description FastAPI Python backend framework for APIs and WebSocket endpoints. Redis In-memory data store for caching and real-time messaging (Pub/Sub). Socket.IO (Python) WebSocket framework for sending real-time data to the frontend. Uvicorn ASGI server to run FastAPI apps. Pandas / NumPy Data processing for technical indicators. CCXT Library for connecting to cryptocurrency exchanges."},{"location":"getting-started/tools_resources/#frontend","title":"\u269b\ufe0f Frontend","text":"Tool / Library Description React UI framework for the dashboard and chatbot interfaces. Vite / Next.js Frontend development tooling (build system, SSR). Socket.IO Client Library for real-time connection to backend signals."},{"location":"getting-started/tools_resources/#data-market-infrastructure","title":"\ud83d\udcca Data &amp; Market Infrastructure","text":"Tool / Service Description TimescaleDB Time-series database (PostgreSQL extension) for historical data. Market Data APIs Data feeds for live crypto prices (e.g., CCXT, CoinMarketCap)."}]}